buildscript {
    ext {
        // Build
        versionSpringBoot = "2.0.3.RELEASE"
        versionSonarQubePlugin = "2.6.2"
        versionArtifactoryPlugin = "4.7.5"
        versionGradleGitProperties = "1.4.17"
    }
    repositories {
        mavenCentral()
        maven {
            url "https://plugins.gradle.org/m2/"
        }
        maven { url "https://artifactory.tingcore-central.com/artifactory/libs-snapshot" }
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:$versionSpringBoot")

        classpath("gradle.plugin.com.gorylenko.gradle-git-properties:gradle-git-properties:$versionGradleGitProperties")
        classpath("org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:$versionSonarQubePlugin")
        classpath("org.jfrog.buildinfo:build-info-extractor-gradle:$versionArtifactoryPlugin")
        classpath("tmp.io.swagger:swagger-codegen:2.3.2-SNAPSHOT")
    }
}

plugins {
    id "com.github.samueltbrown.cucumber" version "0.9"
    id "com.github.hierynomus.license" version "0.14.0"
    id 'com.github.jk1.dependency-license-report' version '0.3.4'
}


import com.github.jk1.license.render.*

apply plugin: "java"
apply plugin: "idea"
apply plugin: "eclipse"
apply plugin: "org.springframework.boot"
apply plugin: "org.sonarqube"
apply plugin: "jacoco"
apply plugin: 'io.spring.dependency-management'


group = "com.tingcore"


sourceCompatibility = 1.8
targetCompatibility = 1.8



jar {
    baseName = "$rootProject.name"
    version = "$project.version"
}

sourceSets {
    main {
        java {
            srcDir "$projectDir/src/main/java"
        }
    }
}

idea {
    project {
        vcs = "Git"
    }
    module {
        downloadSources = true
        sourceDirs -= file("src/resources/java")
    }
}


repositories {
    mavenLocal()
    maven { url "https://artifactory.tingcore-central.com/artifactory/libs-release" }
    maven { url "https://artifactory.tingcore-central.com/artifactory/libs-snapshot" }
    jcenter()
    mavenCentral()
}

configurations.all {
    exclude module: "spring-boot-starter-logging"
    exclude module: "logback-classic"
    exclude group: "org.apache.tomcat", module: "tomcat-jdbc"
}

ext {
    versionSwagger = "2.7.0"
    versionOkHttp = "3.10.0"
    versionCommons = "1.3.12"
    versionJackson = "2.9.4"
    versionCustomerKeyOrderService = '0.5.0'
    versionMicrometer = "1.0.5"
}

dependencies {

    compile project(':models')

    // Spring
    compile("org.springframework.boot:spring-boot-starter-web")
    compile("org.springframework.boot:spring-boot-starter-actuator")
    compile("org.springframework.boot:spring-boot-starter-log4j2")
    compile("org.springframework.boot:spring-boot-devtools")
    compileOnly('org.springframework.boot:spring-boot-configuration-processor')
    compile("org.springframework.cloud:spring-cloud-starter-config")

    // Tingcore
    compile("com.tingcore.commons:core:$versionCommons")
    compile("com.tingcore.commons:rest:$versionCommons")
    compile("com.tingcore.commons:api:$versionCommons")
    compile("com.tingcore.commons:monitoring:$versionCommons")
    compile "com.tingcore:library-eventprocessing:0.0.8"
    compile 'com.squareup.retrofit2:converter-gson:2.3.0'
    compile 'com.google.code.gson:gson:2.8.2'

    // Retrofit + OKHttp
    compile("com.squareup.okhttp3:okhttp:$versionOkHttp")
    compile("com.squareup.okhttp3:logging-interceptor:$versionOkHttp")

    // Swagger
    compile("io.springfox:springfox-swagger2:$versionSwagger")
    compile("io.springfox:springfox-swagger-ui:$versionSwagger")
    compile("io.springfox:springfox-bean-validators:$versionSwagger")

    // Jackson
    compile("com.fasterxml.jackson.core:jackson-databind:$versionJackson")
    compile("com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:$versionJackson")
    compile("com.fasterxml.jackson.datatype:jackson-datatype-jsr310:$versionJackson")
    compile("com.fasterxml.jackson.datatype:jackson-datatype-jdk8:$versionJackson")

    // Apache commons
    compile("org.apache.commons:commons-lang3:3.5")
    compile("org.apache.commons:commons-collections4:4.1")

    // crypto
    compile 'org.hashids:hashids:1.0.3'

    // Google Guava
    compile("com.google.guava:guava")

    // For Log4j2 async logging
    compile("com.lmax:disruptor:3.3.6")

    compileOnly("org.springframework.boot:spring-boot-configuration-processor")

    // Metrics
    compile("io.micrometer:micrometer-registry-prometheus:$versionMicrometer")

    // Tracing
    compile("org.springframework.cloud:spring-cloud-starter-sleuth")
    compile("com.tingcore.spring.starter:spring-cloud-sleuth-xray-starter:0.5.0")
    compile("io.zipkin.brave:brave-instrumentation-okhttp3:5.1.2")

    // Test
    testCompile("com.squareup.okhttp3:mockwebserver:3.10.0")
    testCompile("org.springframework.boot:spring-boot-starter-test")
    testCompile("org.assertj:assertj-core:3.10.0")
    testCompile("io.github.benas:random-beans:3.6.0")
    testCompile('com.google.truth:truth:0.36')
}

dependencyManagement {
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:Finchley.RELEASE"
    }
}

//noinspection GroovyAssignabilityCheck
bootRun {
    systemProperties = System.properties as Map<String, ?>
}

testResultsDirName = "results"

test {
    jacoco {
        append = false
        destinationFile = file("$buildDir/results/jacoco/test.exec")
    }
}


boolean sonarAvailable = false

task setSonarAvailable() {
    doLast {
        try {
            new URL(project.property('systemProp.sonar.host.url') as String).openConnection().connect()
            sonarAvailable = true
        } catch (Exception e) {
            println "WARNING Sonar is unreachable"
        }
    }
}

project.tasks["sonarqube"].dependsOn "setSonarAvailable"
project.tasks["sonarqube"].onlyIf { sonarAvailable }

sonarqube {
    properties {
        property "sonar.projectName", "$rootProject.name"
        property "sonar.projectKey", "$project.group:$rootProject.name"
        property "sonar.projectVersion", "$project.version"
        property "sonar.jacoco.reportPath", "build/results/jacoco/test.exec"
        property "sonar.jacoco.itReportPath", "build/results/jacoco/cucumber.exec"
        property "sonar.junit.reportPaths", "build/results/test,build/results/cucumber"
        property "sonar.coverage.exclusions", "**/*Constants*,**/*Constant*"
        property "sonar.sourceEncoding", "UTF-8"
        property "sonar.language", "java"
    }
}


import io.swagger.codegen.config.CodegenConfigurator
import io.swagger.codegen.DefaultGenerator

def npmName = 'cdc-api-client'
def swaggerInput = "${project.buildDir.path}/swagger/swagger.json"
def swaggerOutputDirTs = file("${projectDir.path}/typescript-client")
task swaggerTs {
    dependsOn 'test'
    inputs.file(swaggerInput)
    outputs.dir(swaggerOutputDirTs)
    doLast {
        def config = new CodegenConfigurator()
        config.addTypeMapping("ChargingKeyOwner", "any")
        config.addTypeMapping("Product", "any")
        config.setInputSpec(swaggerInput)
        config.setOutputDir(swaggerOutputDirTs.path)
        config.setLang("typescript-fetch")
        // Note, @tingcore/ is neccesary for it to be privately scoped
        config.setAdditionalProperties([npmName:'@tingcore/' + npmName, npmVersion: "$version"])
        new DefaultGenerator().opts(config.toClientOptInput()).generate()
    }
}

def swaggerOutputDirJava = file("${projectDir.path}/java-client")
task swaggerJava {
    dependsOn 'test'
    inputs.file(swaggerInput)
    outputs.dir(swaggerOutputDirJava)
    doLast {
        def config = new CodegenConfigurator()
        config.setInputSpec(swaggerInput)
        config.setOutputDir(swaggerOutputDirJava.path)
        config.setLang("java")
        config.setIgnoreFileOverride(".swagger-codegen-ignore")
        config.setLibrary("retrofit2")
        config.setGroupId("com.tingcore")
        config.setArtifactId("cdc-api-java-client")
        config.setArtifactVersion("${version}".toString())
        config.setApiPackage("com.tingcore.cdc.api")
        config.setModelPackage("com.tingcore.cdc.model")
        config.setInvokerPackage("com.tingcore.cdc")
        config.setHttpUserAgent("tingcore-cdc-api/" + config.getArtifactVersion())
        config.addAdditionalProperty("useCompletableFuture", true)
        config.addAdditionalProperty("hideGenerationTimestamp", true)
        config.addAdditionalProperty("java8", true)
        config.addAdditionalProperty("dateLibrary", "java8")
        config.addAdditionalProperty("interfaceOnly", true)

        new DefaultGenerator().opts(config.toClientOptInput()).generate()
    }
}

clean.doFirst {
    delete(swaggerOutputDirTs)
}


springBoot  {
    buildInfo()
}

licenseReport {
    renderer = new CsvReportRenderer()
    configurations = ['compile']
}

allprojects {
    apply plugin: 'com.jfrog.artifactory'
    apply plugin: 'java'

    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8

    // Debugging print task
    task printProjectInfo {
        doLast {
            println "name " + project.name
            println "group " + project.group
            println "version " + project.version
        }
    }
}

subprojects {
    apply plugin: 'idea'
    apply plugin: 'eclipse'
    apply plugin: 'java'
    apply plugin: 'maven'
    apply plugin: 'maven-publish'


    repositories {
        mavenLocal()
        maven { url "https://artifactory.tingcore-central.com/artifactory/libs-release" }
        maven { url "https://artifactory.tingcore-central.com/artifactory/libs-snapshot" }
        mavenCentral()
    }

    dependencies {}

    task sourceJar(type: Jar) {
        from sourceSets.main.allJava
    }

    project.tasks["build"].dependsOn "sourceJar"

    publishing {
        publications {
            mavenJava(MavenPublication) {
                from components.java
                artifact(file("$rootDir/gradle.properties"))

                artifact sourceJar {
                    classifier "sources"
                }
            }
        }
    }

    version = getSanitizedVersion()
    group = "com.tingcore.cdc"
}

artifactoryPublish.skip = true

artifactory {
    publish {
        contextUrl = 'https://artifactory.tingcore-central.com/artifactory'
        repository {
            repoKey = 'libs-snapshot-local' // The Artifactory repository key to publish to
            // username = "input user here for manual testing"
            // password = "input password here for manual testing"

        }
        defaults {
            // Reference to Gradle publications defined in the build script.
            // This is how we tell the Artifactory Plugin which artifacts should be
            // published to Artifactory.
            publications('mavenJava')
            publishArtifacts = true
            // Properties to be attached to the published artifacts.
            // properties = ['qa.level': 'basic', 'dev.team' : 'core']
        }
    }
    resolve {
        contextUrl = 'https://artifactory.tingcore-central.com/artifactory'
        repoKey = 'libs-snapshot'
    }
}

gradle.taskGraph.afterTask { task, state ->
    if (task.name == "artifactoryDeploy" && state.failure) {
        println "WARNING artifactoryDeploy failed"
        println state.failure.getMessage()
        state.failure.printStackTrace()

        // Prevent exit code non-zero which causes Jenkins plugin to fail build.
        state.didWork = true
        state.failure = null
    }
}

String getSanitizedVersion() {
    sanitize(branch()) + rootProject.version
}

// This is the same logic as branch name is determined in Jenkins
static String branch() {
    String job = System.getenv('JOB_NAME')
    if (job == null) {
        job = "/develop"
    }
    String branch = job.split('/').last()

    // Ugly hack for url-decoding for '/'
    return branch.replace("%252F", "/").replace("%2F", "/")
}

static String sanitize(String s) {
    if (s == "develop" || s == "master") {
        return ""
    }
    s.replaceAll("/", "-") + '-'
}
